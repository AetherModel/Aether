// Copyright 2020, the Aether Development Team (see doc/dev_team.md for members)
// Full license can be found in License.md

#include "../include/aether.h"

/**
 * Output function for debugging
 *
 * @param values Values
 * @param filename FileName
 * @param DoAppend
 */
void output(arma_mat &values,
            std::string filename,
            bool DoAppend)
{

  std::ofstream outfile;
  if (DoAppend)
    outfile.open(filename, std::ios_base::app);
  else
  {
    outfile.open(filename);
    int64_t nX = values.n_rows;
    int64_t nY = values.n_cols;
    outfile << nX << " " << nY << "\n";
  }
  outfile << values;
  outfile << "----";
  outfile.close();
}

int main() {

  int iErr = 0;
  std::string sError;
  bool DidWork = true;

  Times time;

  // Define the function and report:
  std::string function = "main";
  static int iFunction = -1;
  report.enter(function, iFunction);

  try {
  
    // Create inputs (reading the input file):
    input = Inputs(time);
    if (!input.is_ok())
      throw std::string("input initialization failed!");
    
    Quadtree quadtree;
    if (!quadtree.is_ok())
      throw std::string("quadtree initialization failed!");
    
    // Initialize MPI and parallel aspects of the code:
    DidWork = init_parallel(quadtree);
    if (!DidWork)
      throw std::string("init_parallel failed!");
    
    // Initialize the planet:
    Planets planet;
    MPI_Barrier(aether_comm);
    if (!planet.is_ok())
      throw std::string("planet initialization failed!");

    // Initialize Geographic grid:
    Grid gGrid(input.get_nLonsGeo(),
	           input.get_nLatsGeo(),
	           input.get_nAltsGeo(),
	           nGeoGhosts);
    DidWork = gGrid.init_geo_grid(quadtree, planet);

    // First check whether the initialization uses exactly 6 processes. 
    // The exactly 6 requirements is due to the checking of the range of reference coordinate system
    int world_size;
    MPI_Comm_size(aether_comm, &world_size);
    if (world_size != 6) {
      throw std::string("Comm size must be 6!!!");
    }

    // Gradient Test
    // Test Cosine Bell
    // Nair Eqn 37
    {
      // Set tolerance limit 
      precision_t tol = 1e-5;

      // Print current side number
      std::string side_num = std::to_string(quadtree.iSide + 1);
      std::cout << "Initiating Tests for Side Number (1-based index): " << side_num << std::endl;

      /**
        * Extract some test data generated by Aether Model
        */
      
      // Cell center coordinates 
      arma_mat aether_lon_cc = gGrid.geoLon_scgc.slice(0);
      arma_mat aether_lat_cc = gGrid.geoLat_scgc.slice(0);

      int64_t nXs = gGrid.get_nY();
      int64_t nYs = gGrid.get_nX();
      int64_t nGCs = gGrid.get_nGCs();
      int64_t nAlts = gGrid.get_nAlts();

      // Test scalar field and gradients
      arma_cube scgc(nXs, nYs, nAlts);
      arma_cube grad_lon_analytical(nXs, nYs, nAlts);
      arma_cube grad_lat_analytical(nXs, nYs, nAlts);

      for (int iAlt = 0; iAlt < nAlts; iAlt++) {
        arma_mat curr_scalar(nXs, nYs, arma::fill::zeros); // setup zero mat
        arma_mat curr_grad_lon(nXs, nYs);
        arma_mat curr_grad_lat(nXs, nYs);
        precision_t A = 1;
        precision_t B = 1;

        for (int j = 0; j < nYs; j++)
        {
          for (int i = 0; i < nXs; i++)
          {
            precision_t curr_lat = aether_lat_cc(i, j);
            precision_t curr_lon = aether_lon_cc(i, j);

            curr_scalar(i,j) = A*std::sin(curr_lat) * std::cos(curr_lon) + B*std::cos(curr_lat)*std::sin(curr_lon);
            curr_grad_lon(i,j) = -A*std::sin(curr_lon)*std::sin(curr_lat) + B*std::cos(curr_lon)*std::cos(curr_lat);
            curr_grad_lat(i,j) = A*std::cos(curr_lon)*std::cos(curr_lat) - B*std::sin(curr_lon)*std::sin(curr_lat);
          }
        }
        scgc.slice(iAlt) = curr_scalar;
        grad_lon_analytical.slice(iAlt) = curr_grad_lon;
        grad_lat_analytical.slice(iAlt) = curr_grad_lat;
      }

      std::vector<arma_cube> test_res = calc_gradient_cubesphere(scgc, gGrid);

      if (side_num == "2") {
        output(scgc.slice(0),"scgc.txt",0);

        output(test_res[0].slice(0),"TEST_RES_GRAD_LON.txt",0);
        output(grad_lon_analytical.slice(0),"ANALYTICAL_GRAD_LON.txt",0);

        output(test_res[1].slice(0),"TEST_RES_GRAD_LAT.txt",0);
        output(grad_lat_analytical.slice(0),"ANALYTICAL_GRAD_LAT.txt",0);

        output(aether_lon_cc,"LON.txt",0);
        output(aether_lat_cc,"LAT.txt",0);

      }
    }
    report.exit(function);
    report.times();

  } catch (std::string error) {
    //if (iProc == 0) {
      std::cout << error << "\n";
      std::cout << "---- Must Exit! ----\n";
    //}
  }
  MPI_Barrier(aether_comm);

    
  // End parallel tasks:
  iErr = MPI_Finalize();

  return iErr;
}